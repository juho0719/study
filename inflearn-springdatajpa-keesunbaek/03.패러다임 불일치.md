# 패러다임 불일치



밀도(Granularity) 문제

| 객체                                                         | 릴레이션                                 |
| ------------------------------------------------------------ | ---------------------------------------- |
| 다양한 크기의 객체를 만들기 있음.<br />커스텀한 타입 만들기 쉬움. | 테이블<br />기본 데이터 타입(UDT는 비추) |



서브타입(Subtype) 문제

| 객체                              | 릴레이션                                                     |
| --------------------------------- | ------------------------------------------------------------ |
| 상속 주고 만들기 쉬움<br />다형성 | 테이블 상속이라는 게 없음<br />상속 기능을 구현했다 하더라도 표준 기술이 아님<br />다형적인 관계를 표현할 방법이 없음 |



식별성(Identity) 문제

| 객체                                                      | 릴레이션           |
| --------------------------------------------------------- | ------------------ |
| 레퍼런스 동일성(==)<br />인스턴스 동일성(equals() 메소드) | 주키 (primary key) |



관계(Association) 문제

| 객체                                                         | 릴레이션                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 객체 레퍼런스로 관계 표현<br />근본적으로 '방향'이 존재<br />다대다 관계를 가질 수 있음 | 외래키(foreign key)로 관계 표현<br />'방향'이라는 의미가 없음. 그냥 Join으로 아무거나<br />묶을 수 있음. 태생적으로 다대다 관계를 못만들고,<br />조인 테이블 또는 링크 테이블을 사용, 두개의 1대다<br />관계로 풀어야 함 |



데이터 네비게이션(Navigation) 문제

| 객체                                                         | 릴레이션                                                     |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| 레퍼런스를 이용해서 다른 객체로 이동 가능<br />콜렉션을 순회할 수도 있음 | 하지만 그런 방식은 릴레이션에서 데이터를 조회하는 데 <br />있어서 매우 비효율적이다.<br />데이터베이스에 요청을 적게 할수록 성능이 좋다. <br />따라서 Join을 쓴다.<br />그렇다고 lazy loading을 하자니 (n+1) 문제 |

