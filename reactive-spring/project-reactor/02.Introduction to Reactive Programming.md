
# Introduction to Reactive Programming
- `Reactor`는 `Reactive Programming` 패러다임의 구현체
- `Reactive Programming`은 데이터 스트림과 변경사항 전파같은 비동기 프로그래밍 패러다임
- 이 의미는 `Reactive Programming`언어를 통해 `arrays`와 같은 정적 데이터와 `event emitters`와 같은 동적 데이터 스트림을 쉽게 사용할 수 있다.
- `Reactive Programming`의 첫번째 단계로 마이크로소프트사는 `.NET` 플랫폼에 `Reactive Extensions(Rx)`라이브러리를 만들었다.
- 그래서 `RxJava`는 `JVM`위에 `Reactive Programming` 으로 구현됐다.
- 시간이 지남에 따라 `Reactive Streams`의 노력으로 `JVM`에 `Reactive Libraries`을 위한 인터페이스 및 규칙들을 정의한 스펙이 자바표준화로 등장
- 해당 인터페이스들은 Java9에서 `Flow`클래스에 통합됨.
- `Reactive Programming` 패러다임은 종종 옵저버 패턴의 확장과 같은 객체지향 언어로 나타낸다.
- 또한, Iterator 디자인패턴과 비슷한 main 리액티브 스트림 패턴과 비교할 수 있다.(모든 라이브러리의 `Iterable-Iterator` pair에 대한 `duality`가 있기 때문)
- 주요 다른 점 중 하나는 Iterator가 `pull-based` 동안 리액티브 스트림은 `push-based` 할 수 있다.
- 값들을 직접 접근하는 방법이 `Iterable`의 단일 책임임에도 불구하고, itorator를 사용하는 것은 `imperative programming pattern`이다.
- 시퀀스에 `next()`를 사용해야 할 시기를 선택하는 것은 개발자의 몫
- 리액티브 스트림에서 위의 `Iterable-Iterator`와 같은 것은 `Publisher-Subscriber`
- `Subscriber`에게 새로운 값들을 알려주는 것은 `Publisher`이며, 이 `push ascpect`는 `reactive`의 핵심이다.
- `pushing aspect`외에도 에러 핸들링과 `complete aspect`도 잘 정의되어 있다.
- `Publisher`는 `onNext`를 통해 `Subscriber`에게 값을 전달할 수도 있지만 `onError`를 통해 에러 신호, 혹은 `onComplete`를 통해 완료 신호를 보낼 수도 있다.
- 에러, 완료 신호 모두 `sequence`를 종료한다.

```
onNext x 0..N [onError | onComplete]
```

- 이러한 방식은 매우 유연하고, 값이 없거나 하나의 값만 있거나 값이 n개일 때 `use case`를 지원한다. (시계의 초침이 계속 가는 것과 같이 무한히 증가하는 `sequence`값도 포함)

### Blocking Can Be Wasteful
- 최신 애플리케이션들은 동시에 수 많은 사용자들이 접근하고, 최신 하드웨어의 성능이 지속적으로 향상됨에도 최신 소프트웨어 성능은 항상 주요 관심사이다.
- 프로그램 성능 향상을 위한 두가지 방법
  - parallelize(병렬처리) : 더 많은 스레드 사용으로 인한 하드웨어 리소스 사용
  - 리소스의 효율적인 사용
- 보통 자바 개발자들은 `blocking` 코드를 작성
- 이 방법은 성능 `bottleneck`이 발생하여 추가 스레드를 도입해야 하는 시점까지는 괜찮은 방법이나, 리소스 확장으로 인한 경합, 동시성 문제가 빠르게 발생할 수 있음
- 프로그램이 대기 시간(특히 데이터베이스 요청, 네트워크 호출과 같은 I/O)을 갖자마자 스레드가 유휴 상태가 되어 데이터를 기다리기 때문에 리소스가 낭비됨
- 그렇다고 병렬 처리 접근만이 능사는 아니다. (No Silver Bullet)
- 순차적으로 접근해야 하는 곳에서는 불필요
- 하드웨어의 모든 기능을 사용하기 위해선 필요하지만, 추론이 복잡하고 자원이 낭비된다

### Asynchronicity to the Rescue?
- 비동기 `non-blocking` 코드로 작성하면 동일한 기본 리소스로 다른 active 작업으로 전환하고, 비동기 처리가 끝났을 때 현재 프로세스로 돌아온다.
- Java는 `Asynchronous Programming`의 두가지 모델을 제시함
  - `Callbacks` : 비동기 메소드들은 리턴값을 가질 수 없지만 `callback` 파라미터를 통해 리턴 값을 받을 수 있다.
  - `Futures`
    - 비동기 메소드들은 즉시 `Future<T>`를 리턴 받음
    - 비동기 프로세스는 `T`에 접근하기 위해 `Future` 객체로 감싸여져 있음
    - 이 값은 즉시 접근 가능하지 않고, 접근이 가능할 때까지 주기적으로 체크함.
    - `Callable<T>` 태스크를 실행하는 `ExecutorService`는 `Future` 객체를 사용함
- 콜백은 읽고, 관리하기 어려운 코드라서 함께 작성하기 어렵다. (`Callback hell`)
- `Callback Hell` 예제

```java
userService.getFavorites(userId, new Callback<List<String>>() { 
  public void onSuccess(List<String> list) { 
    if (list.isEmpty()) { 
      suggestionService.getSuggestions(new Callback<List<Favorite>>() {
        public void onSuccess(List<Favorite> list) { 
          UiUtils.submitOnUiThread(() -> { 
            list.stream()
                .limit(5)
                .forEach(uiList::show); 
            });
        }

        public void onError(Throwable error) { 
          UiUtils.errorPopup(error);
        }
      });
    } else {
      list.stream() 
          .limit(5)
          .forEach(favId -> favoriteService.getDetails(favId, 
            new Callback<Favorite>() {
              public void onSuccess(Favorite details) {
                UiUtils.submitOnUiThread(() -> uiList.show(details));
              }

              public void onError(Throwable error) {
                UiUtils.errorPopup(error);
              }
            }
          ));
    }
  }

  public void onError(Throwable error) {
    UiUtils.errorPopup(error);
  }
});
```
1. 콜백 인터페이스의 메소드는 비동기 처리가 성공했을 때, 혹은 에러가 발생했을 때 호출 (onSuccess, onError)
2. 첫 번째 서비스는 `favorite ID`들의 리스트를 받는 콜백을 호출
3. 그 리스트가 비어있다면, `suggestionService`로 가야함
4. `suggestionService`는 두 번째 콜백으로 `List<Favorite>`를 준다.
5. UI를 다루기 때문에 UI 스레드에서 실행되도록 해야 한다.
6. `Java 8 Stream`을 사용하여 처리되는 제안 갯수를 5개로 제한하고, UI 그래픽 리스트에 제안을 보여준다.
7. 각 레벨에서 같은 방식으로 에러를 처리한다.(팝업으로 보여줌)
8. `favorite ID`레벨로 돌아감. 그 서비스가 전체 리스트를 반환한다면, 우리는 `favoriteService`로 가서 상세한 `Favorite` 오브젝트를 가져와야 한다.
9. 다시 한번 더 콜백이다. 이번에는 UI 스레드 내부의 UI로 푸시하는 `favorite` 객체를 얻음

```java
userService.getFavorites(userId) 
           .flatMap(favoriteService::getDetails) 
           .switchIfEmpty(suggestionService.getSuggestions()) 
           .take(5) 
           .publishOn(UiUtils.uiThreadScheduler()) 
           .subscribe(uiList::show, UiUtils::errorPopup);
```
1. `favorite IDs`로 `flow` 시작
2. 비동기적인 `detailed Favorite objeccts`으로 변환 (flatMap)
3. `flow`가 없다면 `suggestionService`를 통해 `fallback`으로 전환
4. 결과 `flow`에서 5개만 추출
5. UI 스레드에서 각각의 데이터 조각을 처리
6. 최종적으로 UI에 보여줄 리스트, 혹은 오류 팝업과 같이 수행할 작업을 처리