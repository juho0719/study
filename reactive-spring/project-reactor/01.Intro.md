# Intro
- Project Reactor는 JVM을 위한 non-blocking reactive 프로그래밍
- Java 8 함수형 APIs로의 통합(특히 `CompletableFuture`, `Stream`, `Duration` )
- 비동기 시퀀스 APIs `Flux`, `Mono`를 제공하여 더 확장된 Reactive Steram 명세를 구현
- `reactor-netty` project로 non-blocking 통신 지원
- 마이크로서비스 아키텍처에 적합한 `reactor-netty`는 `HTTP`, `TCP`, `UDP`를 위한 backpressure-ready 네트워크 엔진을 제공
- Reactive Encoding, Decoding 양방향 지원

# Prerequisites(전제조건)
- Reactor Core를 실행하기 위해 최소 Java 8이상 
- org.reactivestreams:reactive-streams:1.0.2 (dependency)

# Understanding the BOM
- Reactor3는 `reactor-core 3.0.4` BOM 모델을 사용
- release code name
  - Aluminium-RELEASE
  - Californium-BUILD-SNAPSHOT
  - Aluminium-SR1
  - Bismuth-RELEASE
  - Californium-SR32

# Getting Reactor
- Reactor를 사용하는 가장 쉬운 방법은 BOM을 사용하고 의존성을 프로젝트에 추가하는 것
- 특정 버전 사용을 원하다면 의존성 버전도 특정 버전을 사용

### Maven Installation
- `pom.xml`에 다음 코드 추가 (`dependencyManagement`나 `denpendencies`가 이미 있다면 `dependency` 하위 내용만 추가)
```xml
<dependencyManagement>
  <dependencies>
    <dependency>
      <groupId>io.projectreactor</groupId>
      <artifactId>reactor-bom</artifactId>
      <version>Bismuth-RELEASE</version>
      <type>pom</type>
      <scopt>import</scope>
    </dependency>
  </dependencies>
</dependencyManagement>
```
- `denpendencies`안에 `<version>`을 제외하고 `reactor-core`, `reactor-test` 추가
```xml
<dependencies>
  <dependency>
    <groupId>io.projectreactor</groupId>
    <artifactId>reactor-core</artifactId>
  </dependency>
  <dependency>
    <groupId>io.projectreactor</groupId>
    <artifactId>reactor-test</artifactId>
    <scopt>test</scope>
  </dependency>
</dependencies>
```

### Gradle Installation
- Gradle은 Maven BOM을 지원하는 core가 없어 스프링의 `gradle-dependency-management` 플러그인을 사용해야 함
- `1.0.6.RELEASE`는 사용시기의 가장 마지막 버전으로 대체 가능
```
plugins {
  id "io.spring.dependency-management" version "1.0.6.RELEASE"
}
```
- `BOM`을 import 
```
dependencyManagement {
  imports {
    mavenBom "io.projectreactor:reactor-bom:Bismuth-RELEASE"
  }
}
```
- `reactor-core` 의존성 추가
```
dependencies {
  compile 'io.projectreactor:reactor-core'
}
```

### Milstones and Snapshots
- Milestones와 Developer previews는 Maven Central보다 Spring Milestones repository를 통해 배포

#### Milstones in Maven
```xml
<repositories>
  <repository>
    <id>spring-milestones</id>
    <name>Spring Milestones Repository</name>
    <url>https://repo.spring.io/milestone</url>
  </repository>
</repositories>
```

#### Milestones in Gradle
```
repositories {
  maven { url 'https://repo.spring.io/milestone' }
  mavenCentral()
}
```

#### BUILD-SNAPSHOT in Maven
```xml
<repositories>
  <repository>
    <id>spring-snapshots</id>
    <name>Spring Snapshot Repository</name>
    <url>https://repo.spring.io/snapshot</url>
  </repository>
</repositories>
```

#### BUILD-SNAPSHOT in Gradle
```
repositories {
  maven { url 'https://repo.spring.io/snapshot' }
  mavenCentral()
}
```

# Introduction to Reactive Programming
- `Reactor`는 `Reactive Programming` 패러다임의 구현체
- `Reactive Programming`은 데이터 스트림과 변경사항 전파같은 비동기 프로그래밍 패러다임
- 이 의미는 `Reactive Programming`언어를 통해 `arrays`와 같은 정적 데이터와 `event emitters`와 같은 동적 데이터 스트림을 쉽게 사용할 수 있다.
- `Reactive Programming`의 첫번째 단계로 마이크로소프트사는 `.NET` 플랫폼에 `Reactive Extensions(Rx)`라이브러리를 만들었다.
- 그래서 `RxJava`는 `JVM`위에 `Reactive Programming` 으로 구현됐다.
- 시간이 지남에 따라 `Reactive Streams`의 노력으로 `JVM`에 `Reactive Libraries`을 위한 인터페이스 및 규칙들을 정의한 스펙이 자바표준화로 등장
- 해당 인터페이스들은 Java9에서 `Flow`클래스에 통합됨.
- `Reactive Programming` 패러다임은 종종 옵저버 패턴의 확장과 같은 객체지향 언어로 나타낸다.
- 또한, Iterator 디자인패턴과 비슷한 main 리액티브 스트림 패턴과 비교할 수 있다.(모든 라이브러리의 `Iterable-Iterator` pair에 대한 `duality`가 있기 때문)
- 주요 다른 점 중 하나는 Iterator가 `pull-based` 동안 리액티브 스트림은 `push-based` 할 수 있다.
- 값들을 직접 접근하는 방법이 `Iterable`의 단일 책임임에도 불구하고, itorator를 사용하는 것은 `imperative programming pattern`이다.
- 시퀀스에 `next()`를 사용해야 할 시기를 선택하는 것은 개발자의 몫
- 리액티브 스트림에서 위의 `Iterable-Iterator`와 같은 것은 `Publisher-Subscriber`
- `Subscriber`에게 새로운 값들을 알려주는 것은 `Publisher`이며, 이 `push ascpect`는 `reactive`의 핵심이다.
- `pushing aspect`외에도 에러 핸들링과 `complete aspect`도 잘 정의되어 있다.
- `Publisher`는 `onNext`를 통해 `Subscriber`에게 값을 전달할 수도 있지만 `onError`를 통해 에러 신호, 혹은 `onComplete`를 통해 완료 신호를 보낼 수도 있다.
- 에러, 완료 신호 모두 `sequence`를 종료한다.

```
onNext x 0..N [onError | onComplete]
```

- 이러한 방식은 매우 유연하고, 값이 없거나 하나의 값만 있거나 값이 n개일 때 `use case`를 지원한다. (시계의 초침이 계속 가는 것과 같이 무한히 증가하는 `sequence`값도 포함)

### Blocking Can Be Wasteful
- 최신 애플리케이션들은 동시에 수 많은 사용자들이 접근하고, 최신 하드웨어의 성능이 지속적으로 향상됨에도 최신 소프트웨어 성능은 항상 주요 관심사이다.
- 프로그램 성능 향상을 위한 두가지 방법
  - parallelize(병렬처리) : 더 많은 스레드 사용으로 인한 하드웨어 리소스 사용
  - 리소스의 효율적인 사용
- 보통 자바 개발자들은 `blocking` 코드를 작성
- 이 방법은 성능 `bottleneck`이 발생하여 추가 스레드를 도입해야 하는 시점까지는 괜찮은 방법이나, 리소스 확장으로 인한 경합, 동시성 문제가 빠르게 발생할 수 있음
- 프로그램이 대기 시간(특히 데이터베이스 요청, 네트워크 호출과 같은 I/O)을 갖자마자 스레드가 유휴 상태가 되어 데이터를 기다리기 때문에 리소스가 낭비됨
- 그렇다고 병렬 처리 접근만이 능사는 아니다. (No Silver Bullet)
- 순차적으로 접근해야 하는 곳에서는 불필요
- 하드웨어의 모든 기능을 사용하기 위해선 필요하지만, 추론이 복잡하고 자원이 낭비된다

### Asynchronicity to the Rescue?
- 비동기 `non-blocking` 코드로 작성하면 동일한 기본 리소스로 다른 active 작업으로 전환하고, 비동기 처리가 끝났을 때 현재 프로세스로 돌아온다.
- Java는 `Asynchronous Programming`의 두가지 모델을 제시함
  - `Callbacks` : `Asynchronous` 메소드들은 리턴값을 가질 수 없지만 `callback` 파라미터를 통해 리턴 값을 받을 수 있다.







### Project Reactor Features
- 더 나은 효율성으로 높은 대기시간 처리
  - Downstream service
	- Database call
- Bloking Operations 리소스 소비를 최소화
  - reactive type은 기다리는 비용이 없기 때문
- 어플리케이션의 더 많은 부하를 허용

### Reactor Project Structure