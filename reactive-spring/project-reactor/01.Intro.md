# Intro
- Project Reactor는 JVM을 위한 non-blocking reactive 프로그래밍
- Java 8 함수형 APIs로의 통합(특히 `CompletableFuture`, `Stream`, `Duration` )
- 비동기 시퀀스 APIs `Flux`, `Mono`를 제공하여 더 확장된 Reactive Steram 명세를 구현
- `reactor-netty` project로 non-blocking 통신 지원
- 마이크로서비스 아키텍처에 적합한 `reactor-netty`는 `HTTP`, `TCP`, `UDP`를 위한 backpressure-ready 네트워크 엔진을 제공
- Reactive Encoding, Decoding 양방향 지원

# Prerequisites(전제조건)
- Reactor Core를 실행하기 위해 최소 Java 8이상 
- org.reactivestreams:reactive-streams:1.0.2 (dependency)

# Understanding the BOM
- Reactor3는 `reactor-core 3.0.4` BOM 모델을 사용
- release code name
  - Aluminium-RELEASE
  - Californium-BUILD-SNAPSHOT
  - Aluminium-SR1
  - Bismuth-RELEASE
  - Californium-SR32

# Getting Reactor
- Reactor를 사용하는 가장 쉬운 방법은 BOM을 사용하고 의존성을 프로젝트에 추가하는 것
- 특정 버전 사용을 원하다면 의존성 버전도 특정 버전을 사용

### Maven Installation
- `pom.xml`에 다음 코드 추가 (`dependencyManagement`나 `denpendencies`가 이미 있다면 `dependency` 하위 내용만 추가)
```xml
<dependencyManagement>
  <dependencies>
    <dependency>
      <groupId>io.projectreactor</groupId>
      <artifactId>reactor-bom</artifactId>
      <version>Bismuth-RELEASE</version>
      <type>pom</type>
      <scopt>import</scope>
    </dependency>
  </dependencies>
</dependencyManagement>
```
- `denpendencies`안에 `<version>`을 제외하고 `reactor-core`, `reactor-test` 추가
```xml
<dependencies>
  <dependency>
    <groupId>io.projectreactor</groupId>
    <artifactId>reactor-core</artifactId>
  </dependency>
  <dependency>
    <groupId>io.projectreactor</groupId>
    <artifactId>reactor-test</artifactId>
    <scopt>test</scope>
  </dependency>
</dependencies>
```

### Gradle Installation
- Gradle은 Maven BOM을 지원하는 core가 없어 스프링의 `gradle-dependency-management` 플러그인을 사용해야 함
- `1.0.6.RELEASE`는 사용시기의 가장 마지막 버전으로 대체 가능
```
plugins {
  id "io.spring.dependency-management" version "1.0.6.RELEASE"
}
```
- `BOM`을 import 
```
dependencyManagement {
  imports {
    mavenBom "io.projectreactor:reactor-bom:Bismuth-RELEASE"
  }
}
```
- `reactor-core` 의존성 추가
```
dependencies {
  compile 'io.projectreactor:reactor-core'
}
```

### Milstones and Snapshots
- Milestones와 Developer previews는 Maven Central보다 Spring Milestones repository를 통해 배포

#### Milstones in Maven
```xml
<repositories>
  <repository>
    <id>spring-milestones</id>
    <name>Spring Milestones Repository</name>
    <url>https://repo.spring.io/milestone</url>
  </repository>
</repositories>
```

#### Milestones in Gradle
```
repositories {
  maven { url 'https://repo.spring.io/milestone' }
  mavenCentral()
}
```

#### BUILD-SNAPSHOT in Maven
```xml
<repositories>
  <repository>
    <id>spring-snapshots</id>
    <name>Spring Snapshot Repository</name>
    <url>https://repo.spring.io/snapshot</url>
  </repository>
</repositories>
```

#### BUILD-SNAPSHOT in Gradle
```
repositories {
  maven { url 'https://repo.spring.io/snapshot' }
  mavenCentral()
}
```

# Introduction to Reactive Programming
- `Reactor`는 `Reactive Programming` 패러다임의 구현체
- `Reactive Programming`은 데이터 스트림과 변경사항 전파같은 비동기 프로그래밍 패러다임
- 이 의미는 `Reactive Programming`언어를 통해 `arrays`와 같은 정적 데이터와 `event emitters`와 같은 동적 데이터 스트림을 쉽게 사용할 수 있다.
- `Reactive Programming`의 첫번째 단계로 마이크로소프트사는 `.NET` 플랫폼에 `Reactive Extensions(Rx)`라이브러리를 만들었다.
- 그래서 `RxJava`는 `JVM`위에 `Reactive Programming` 으로 구현됐다.
- 시간이 지남에 따라 `Reactive Streams`의 노력으로 `JVM`에 `Reactive Libraries`을 위한 인터페이스 및 규칙들을 정의한 스펙이 자바표준화로 등장
- 해당 인터페이스들은 Java9에서 `Flow`클래스에 통합됨.
- `Reactive Programming` 패러다임은 종종 옵저버 패턴의 확장과 같은 객체지향 언어로 나타낸다.
- 또한, Iterator 디자인패턴과 비슷한 main 리액티브 스트림 패턴과 비교할 수 있다.(모든 라이브러리의 `Iterable-Iterator` pair에 대한 `duality`가 있기 때문)
- 주요 다른 점 중 하나는 Iterator가 `pull-based` 동안 리액티브 스트림은 `push-based` 할 수 있다.
- 값들을 직접 접근하는 방법이 `Iterable`의 단일 책임임에도 불구하고, itorator를 사용하는 것은 `imperative programming pattern`이다.
- 시퀀스에 `next()`를 사용해야 할 시기를 선택하는 것은 개발자의 몫
- 리액티브 스트림에서 위의 `Iterable-Iterator`와 같은 것은 `Publisher-Subscriber`


### Project Reactor Features
- 더 나은 효율성으로 높은 대기시간 처리
  - Downstream service
	- Database call
- Bloking Operations 리소스 소비를 최소화
  - reactive type은 기다리는 비용이 없기 때문
- 어플리케이션의 더 많은 부하를 허용

### Reactor Project Structure